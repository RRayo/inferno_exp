<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Face Detection</title>
  <script type="module">
    import { FaceDetector, FilesetResolver } from "./tasks-vision@0.10.0.js";
    
    let faceDetector;
    let runningMode = "IMAGE";
    const video = document.getElementById("webcam");
    const liveView = document.getElementById("liveView");
    const children = [];

    async function initializeFaceDetector() {
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.12/wasm"
      );
      faceDetector = await FaceDetector.createFromOptions(vision, {
        baseOptions: { modelAssetPath: "blaze_face_short_range.tflite", delegate: "GPU" },
        runningMode
      });
      startWebcam();
    }

    function hasGetUserMedia() {
      return !!navigator.mediaDevices?.getUserMedia;
    }

    async function startWebcam() {
      if (!faceDetector || !hasGetUserMedia()) return;

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;
        video.addEventListener("loadeddata", predictWebcam);
      } catch (err) {
        console.error("No se pudo acceder a la webcam:", err);
      }
    }

    let lastVideoTime = -1;
    async function predictWebcam() {
      // Ajustar el modo de ejecución la primera vez
      if (runningMode === "IMAGE") {
        runningMode = "VIDEO";
        await faceDetector.setOptions({ runningMode });
      }

      const startTimeMs = performance.now();
      if (video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;
        const detections = faceDetector.detectForVideo(video, startTimeMs)?.detections;
        if (detections) {
            displayDetections(detections);
        }
      }
      requestAnimationFrame(predictWebcam);
    }

    function displayDetections(detections) {
      // Limpiar detecciones anteriores
      for (let child of children) liveView.removeChild(child);
      children.length = 0;

      // --- INICIO DE LA LÓGICA DE CÁLCULO MODIFICADA ---
      // Obtener las dimensiones reales del video y del elemento en pantalla
      const videoRatio = video.videoWidth / video.videoHeight;
      const viewRatio = video.clientWidth / video.clientHeight;

      let scale = 1;
      let offsetX = 0;
      let offsetY = 0;
      
      // 'object-fit: cover' escala el video para llenar el contenedor.
      // Necesitamos replicar esa lógica para que las coordenadas coincidan.
      if (videoRatio > viewRatio) {
        // El video es más ancho que la vista, se ajusta a la altura y se recorta horizontalmente.
        scale = video.clientHeight / video.videoHeight;
        offsetX = (video.clientWidth - video.videoWidth * scale) / 2;
      } else {
        // El video es más alto que la vista, se ajusta al ancho y se recorta verticalmente.
        scale = video.clientWidth / video.videoWidth;
        offsetY = (video.clientHeight - video.videoHeight * scale) / 2;
      }
      // --- FIN DE LA LÓGICA DE CÁLCULO MODIFICADA ---


      for (let det of detections) {
        // Calcular las dimensiones y posiciones escaladas
        const scaledWidth = det.boundingBox.width * scale;
        const scaledHeight = det.boundingBox.height * scale;
        const scaledOriginX = det.boundingBox.originX * scale;
        const scaledOriginY = det.boundingBox.originY * scale;

        // Bounding box
        const box = document.createElement("div");
        box.className = "highlighter";
        
        // La lógica del `left` se ajusta para el espejo (transform: rotateY(180deg))
        // y para el nuevo escalado y desplazamiento.
        box.style.cssText = `
          left:${video.clientWidth - scaledOriginX - scaledWidth - offsetX}px;
          top:${scaledOriginY + offsetY}px;
          width:${scaledWidth}px;
          height:${scaledHeight}px;
        `;
        liveView.appendChild(box);
        children.push(box);

        // Confianza
        const p = document.createElement("p");
        p.innerText = "Confidence: " + Math.round(det.categories[0].score * 100) + "%";
        p.style.cssText = `
          left:${video.clientWidth - scaledOriginX - scaledWidth - offsetX}px;
          top:${scaledOriginY + offsetY - 30}px;
          width:${scaledWidth}px;
        `;
        liveView.appendChild(p);
        children.push(p);

        // Keypoints
        for (let k of det.keypoints) {
          const kp = document.createElement("span");
          kp.className = "key-point";
          
          // Se aplica la misma lógica de escalado, desplazamiento y espejo a los keypoints
          const keypointX = video.clientWidth - (k.x * video.videoWidth * scale) - offsetX;
          const keypointY = (k.y * video.videoHeight * scale) + offsetY;

          kp.style.left = `${keypointX - 3}px`;
          kp.style.top = `${keypointY - 3}px`;
          liveView.appendChild(kp);
          children.push(kp);
        }
      }
    }

    initializeFaceDetector();
  </script>
  <style>
    /* --- INICIO DE ESTILOS MODIFICADOS --- */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden; /* Evita barras de scroll */
      font-family: roboto, sans-serif;
      color: #3d3d3d;
    }

    h1 {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
      z-index: 10;
    }

    .videoView {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    video {
      /* Esto asegura que el video siempre cubra toda la altura de la pantalla,
         manteniendo su aspect ratio y centrando/recortando el exceso horizontal */
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: rotateY(180deg);
      -webkit-transform: rotateY(180deg); /* Safari & iOS */
    }

    .highlighter {
      position: absolute;
      /* Color cambiado a un blanco casi transparente */
      background: rgba(255, 255, 255, 0.1);
      border: 1px dashed #fff;
      z-index: 1;
    }
    /* --- FIN DE ESTILOS MODIFICADOS --- */

    .key-point {
      position: absolute;
      width: 3px;
      height: 3px;
      background: red;
      border-radius: 50%;
      z-index: 2;
    }

    p {
      position: absolute;
      padding: 5px;
      background: #007f8b;
      color: #fff;
      font-size: 12px;
      margin: 0;
      z-index: 2;
    }
  </style>
</head>
<body>
  <h1>Face Detection Demo</h1>
  <div id="liveView" class="videoView">
    <video id="webcam" autoplay playsinline></video>
  </div>
</body>
</html>